import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const VERSION = "AssistantPath v2025-08-26-Enhanced-60s-Timeout";
const openAIApiKey = Deno.env.get('OPENAI_API_KEY');
const openAIProjectId = Deno.env.get('OPENAI_PROJECT_ID');
const assistantId = Deno.env.get('ASSISTANT_ID');

console.log(`üöÄ ${VERSION} - Starting analyze-assistant function`);
console.log(`Environment check: { hasOpenaiKey: ${!!openAIApiKey}, openaiKeyLength: ${openAIApiKey?.length || 0}, hasProjectId: ${!!openAIProjectId}, hasAssistantId: ${!!assistantId}, assistantIdLength: ${assistantId?.length || 0} }`);

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const ALLOWED_CRITERIA = [
  'timeline',
  'integrator', 
  'reporting',
  'evaluation',
  'external_audit',
  'resources',
  'multi_levels',
  'structure',
  'field_implementation',
  'arbitrator',
  'cross_sector',
  'outcomes',
] as const;

serve(async (req) => {
  console.log(`üì• ${VERSION} - Request received: ${req.method} at ${new Date().toISOString()}`);
  
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    console.log(`‚úÖ ${VERSION} - Handling CORS preflight`);
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { content, maxInsights = 24 } = await req.json();
    console.log(`üìã ${VERSION} - Request parsed: contentLength=${content?.length || 0}, maxInsights=${maxInsights}`);

    // Check required secrets
    if (!openAIApiKey || !assistantId) {
      console.error(`‚ùå ${VERSION} - Missing required API keys: hasOpenaiKey=${!!openAIApiKey}, hasAssistantId=${!!assistantId}`);
      return new Response(
        JSON.stringify({ error: 'Missing required API keys', version: VERSION }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!content || typeof content !== 'string' || !content.trim()) {
      console.log(`‚ö†Ô∏è ${VERSION} - Empty content provided`);
      return new Response(
        JSON.stringify({ insights: [], criteria: [], summary: null, version: VERSION }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Enhanced content handling for long texts
    const isLongText = content.length > 4000;
    const adjustedMaxInsights = isLongText ? Math.max(maxInsights, 32) : maxInsights;
    const truncatedContent = content.length > 15000 ? content.substring(0, 15000) + "..." : content; // Increased limit
    console.log(`üìù ${VERSION} - Content prepared: originalLength=${content.length}, isLongText=${isLongText}, adjustedMaxInsights=${adjustedMaxInsights}, truncatedLength=${truncatedContent.length}`);

    // Enhanced timeout for long texts - increased to 60 seconds
    const timeoutDuration = isLongText ? 60000 : 30000; // 60s for long texts, 30s for normal
    const maxPollingAttempts = isLongText ? 30 : 15; // 30 attempts for long texts (60s total)
    
    // Create AbortController for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);

    try {
      console.log(`üîÑ ${VERSION} - Step 1: Creating thread with timeout ${timeoutDuration}ms`);
      
      // Prepare headers - don't include OpenAI-Organization header to avoid the mismatch error
      const headers: Record<string, string> = {
        'Authorization': `Bearer ${openAIApiKey}`,
        'Content-Type': 'application/json',
        'OpenAI-Beta': 'assistants=v2',
      };
      
      console.log(`üîß ${VERSION} - Using headers without OpenAI-Organization to avoid mismatch error`);

      // Step 1: Create a thread
      const threadResponse = await fetch('https://api.openai.com/v1/threads', {
        method: 'POST',
        headers,
        body: JSON.stringify({}),
        signal: controller.signal,
      });

      if (!threadResponse.ok) {
        const threadError = await threadResponse.json().catch(() => ({}));
        console.error(`‚ùå ${VERSION} - Thread creation failed:`, threadError);
        throw new Error(`Failed to create thread: ${threadError.error?.message || 'Unknown error'}`);
      }

      const thread = await threadResponse.json();
      const threadId = thread.id;
      console.log(`‚úÖ ${VERSION} - Thread created: ${threadId}`);

      // Enhanced prompt for better Hebrew processing and comprehensive text analysis
      const enhancedPrompt = `◊†◊™◊ó ◊ê◊™ ◊î◊û◊°◊û◊ö ◊î◊û◊û◊©◊ú◊™◊ô ◊î◊ë◊ê ◊ï◊™◊ü ◊ë◊ô◊ß◊ï◊®◊™ ◊û◊ß◊ô◊§◊î ◊¢◊ú ◊§◊ô ◊®◊ï◊ë◊®◊ô◊ß◊™ 12 ◊î◊ß◊®◊ô◊ò◊®◊ô◊ï◊†◊ô◊ù.

üî• ◊î◊†◊ó◊ô◊ï◊™ ◊ß◊®◊ô◊ò◊ô◊ï◊™ - ◊ß◊®◊ê ◊ë◊ß◊§◊ô◊ì◊î ◊ï◊î◊ß◊§◊ì ◊¢◊ú ◊ô◊ô◊©◊ï◊û◊ü:

1. **◊†◊ô◊™◊ï◊ó ◊û◊ú◊ê ◊ï◊û◊ß◊ô◊£ ◊©◊ú ◊õ◊ú ◊î◊ò◊ß◊°◊ò**: 
   - ◊†◊™◊ó ◊ê◊™ ◊õ◊ú ◊ó◊ú◊ß◊ô ◊î◊û◊°◊û◊ö ◊û◊™◊ó◊ô◊ú◊™◊ï ◊ï◊¢◊ì ◊°◊ï◊§◊ï - ◊ñ◊î ◊ó◊ï◊ë◊î!
   - ◊ï◊ï◊ì◊ê ◊©◊î◊™◊ï◊ë◊†◊ï◊™ ◊û◊§◊ï◊ñ◊®◊ï◊™ ◊¢◊ú ◊§◊†◊ô ◊õ◊ú ◊î◊ò◊ß◊°◊ò (◊™◊ó◊ô◊ú◊î 30%, ◊ê◊û◊¶◊¢ 40%, ◊°◊ï◊£ 30%)
   - ◊ê◊ú ◊™◊™◊¢◊ú◊ù ◊û◊î◊ó◊ú◊ß◊ô◊ù ◊î◊ê◊ó◊®◊ï◊†◊ô◊ù ◊©◊ú ◊î◊û◊°◊û◊ö - ◊î◊ù ◊ú◊¢◊ô◊™◊ô◊ù ◊û◊õ◊ô◊ú◊ô◊ù ◊§◊®◊ò◊ô◊ù ◊ó◊©◊ï◊ë◊ô◊ù
   - ${isLongText ? '◊ò◊ß◊°◊ò ◊ñ◊î ◊ê◊®◊ï◊ö ◊ë◊û◊ô◊ï◊ó◊ì - ◊ó◊ï◊ë◊î ◊ú◊†◊™◊ó ◊í◊ù ◊ê◊™ ◊î◊ó◊ú◊ß◊ô◊ù ◊î◊û◊ê◊ï◊ó◊®◊ô◊ù!' : ''}

2. **◊õ◊û◊ï◊™ ◊î◊™◊ï◊ë◊†◊ï◊™ ◊†◊ì◊®◊©◊™**: ◊¶◊ï◊® ◊ë◊ì◊ô◊ï◊ß ${adjustedMaxInsights} ◊™◊ï◊ë◊†◊ï◊™ ◊û◊§◊ï◊®◊ò◊ï◊™
   - ${isLongText ? '◊¢◊ë◊ï◊® ◊ò◊ß◊°◊ò ◊ê◊®◊ï◊ö ◊ñ◊î, ◊ó◊ï◊ë◊î ◊ú◊û◊¶◊ï◊ê ◊™◊ï◊ë◊†◊ï◊™ ◊í◊ù ◊û◊î◊ó◊ú◊ß ◊î◊ê◊ó◊®◊ï◊ü ◊©◊ú ◊î◊û◊°◊û◊ö' : ''}
   - ◊ó◊ú◊ß ◊ê◊™ ◊î◊™◊ï◊ë◊†◊ï◊™ ◊ë◊ê◊ï◊§◊ü ◊©◊ï◊ï◊î ◊ë◊ô◊ü ◊î◊ß◊®◊ô◊ò◊®◊ô◊ï◊†◊ô◊ù ◊î◊©◊ï◊†◊ô◊ù
   - ◊õ◊ú ◊ß◊®◊ô◊ò◊®◊ô◊ï◊ü ◊ó◊ô◊ô◊ë ◊ú◊ß◊ë◊ú ◊ú◊§◊ó◊ï◊™ 2-3 ◊™◊ï◊ë◊†◊ï◊™

3. **◊¶◊ô◊ò◊ï◊ò◊ô◊ù ◊û◊ì◊ï◊ô◊ß◊ô◊ù ◊ë◊®◊û◊î ◊í◊ë◊ï◊î◊î**:
   - ◊î◊©◊™◊û◊© ◊ë◊¶◊ô◊ò◊ï◊ò◊ô◊ù ◊ß◊¶◊®◊ô◊ù ◊ï◊û◊ì◊ï◊ô◊ß◊ô◊ù (20-50 ◊™◊ï◊ï◊ô◊ù ◊ë◊ú◊ë◊ì)
   - ◊¶◊ô◊ò◊ï◊ò ◊ó◊ô◊ô◊ë ◊ú◊î◊ï◊§◊ô◊¢ ◊ë◊ì◊ô◊ï◊ß ◊ë◊û◊°◊û◊ö ◊õ◊§◊ô ◊©◊ê◊™◊î ◊û◊¶◊ô◊ô◊ü
   - ◊î◊ô◊û◊†◊¢ ◊û◊®◊ï◊ï◊ó◊ô◊ù ◊û◊ô◊ï◊™◊®◊ô◊ù ◊ë◊™◊ó◊ô◊ú◊™ ◊ê◊ï ◊°◊ï◊£ ◊î◊¶◊ô◊ò◊ï◊ò
   - ◊ï◊ì◊ê ◊©◊î-rangeStart ◊ï◊î-rangeEnd ◊û◊ì◊ï◊ô◊ß◊ô◊ù ◊ú◊ó◊ú◊ï◊ò◊ô◊ü

4. **◊¢◊ë◊®◊ô◊™ ◊ë◊ú◊ë◊ì**: ◊õ◊ú ◊î◊™◊ï◊õ◊ü ◊ó◊ô◊ô◊ë ◊ú◊î◊ô◊ï◊™ ◊ë◊¢◊ë◊®◊ô◊™ ◊û◊ï◊©◊ú◊û◊™ ◊ë◊®◊û◊î ◊ê◊ß◊ì◊û◊ô◊™!

5. **◊î◊™◊û◊ó◊ï◊™ ◊ë◊ò◊ß◊°◊ò ◊û◊û◊©◊ú◊™◊ô ◊¢◊ë◊®◊ô**:
   - ◊ñ◊î◊î ◊û◊ï◊†◊ó◊ô◊ù ◊û◊ß◊¶◊ï◊¢◊ô◊ô◊ù ◊û◊û◊©◊ú◊™◊ô◊ô◊ù
   - ◊î◊™◊û◊ß◊ì ◊ë◊ó◊°◊®◊ô◊ù ◊û◊ë◊†◊ô◊ô◊ù ◊ï◊™◊î◊ú◊ô◊õ◊ô◊ô◊ù
   - ◊ñ◊î◊î ◊ë◊¢◊ô◊ï◊™ ◊ë◊î◊í◊ì◊®◊™ ◊ê◊ó◊®◊ô◊ï◊™ ◊ï◊°◊û◊õ◊ï◊ô◊ï◊™
   - ◊î◊™◊ô◊ô◊ó◊° ◊ú◊ó◊ï◊°◊® ◊ë◊ú◊ï◊ó◊ï◊™ ◊ñ◊û◊†◊ô◊ù ◊ï◊û◊†◊í◊†◊ï◊†◊ô ◊§◊ô◊ß◊ï◊ó

◊¢◊ë◊ï◊® ◊õ◊ú insight, ◊õ◊ú◊ï◊ú:
- explanation: ◊î◊°◊ë◊® ◊ë◊®◊ï◊® ◊ï◊û◊ì◊ï◊ô◊ß ◊©◊ú ◊î◊ë◊¢◊ô◊î ◊ê◊ï ◊î◊ó◊ï◊ñ◊ß◊î (30-50 ◊û◊ô◊ú◊ô◊ù ◊ë◊¢◊ë◊®◊ô◊™)
- suggestion: ◊î◊¶◊¢◊î ◊ß◊¶◊®◊î ◊ú◊©◊ô◊§◊ï◊® (15-25 ◊û◊ô◊ú◊ô◊ù ◊ë◊¢◊ë◊®◊ô◊™)  
- suggestion_primary: ◊î◊¶◊¢◊î ◊û◊§◊ï◊®◊ò◊™ ◊®◊ê◊©◊ï◊†◊ô◊™ (50-80 ◊û◊ô◊ú◊ô◊ù ◊ë◊¢◊ë◊®◊ô◊™)
- suggestion_secondary: ◊î◊¶◊¢◊î ◊ó◊ú◊ï◊§◊ô◊™ ◊ê◊ï ◊û◊©◊ú◊ô◊û◊î (50-80 ◊û◊ô◊ú◊ô◊ù ◊ë◊¢◊ë◊®◊ô◊™)
- quote: ◊¶◊ô◊ò◊ï◊ò ◊ß◊¶◊® ◊ï◊û◊ì◊ï◊ô◊ß ◊û◊î◊û◊°◊û◊ö (20-50 ◊™◊ï◊ï◊ô◊ù)
- rangeStart, rangeEnd: ◊û◊ô◊ß◊ï◊ù ◊û◊ì◊ï◊ô◊ß ◊©◊ú ◊î◊¶◊ô◊ò◊ï◊ò ◊ë◊ò◊ß◊°◊ò

${isLongText ? `
‚ö†Ô∏è ◊ò◊ß◊°◊ò ◊ê◊®◊ï◊ö - ◊î◊†◊ó◊ô◊ï◊™ ◊†◊ï◊°◊§◊ï◊™ ◊ó◊ï◊ë◊î:
- ◊§◊ñ◊® ◊™◊ï◊ë◊†◊ï◊™ ◊¢◊ú ◊§◊†◊ô ◊õ◊ú ◊î◊ò◊ß◊°◊ò: ◊™◊ó◊ô◊ú◊î (30%), ◊ê◊û◊¶◊¢ (40%), ◊°◊ï◊£ (30%)
- ◊ó◊ï◊ë◊î ◊ú◊†◊™◊ó ◊í◊ù ◊ê◊™ ◊î◊ó◊ú◊ß◊ô◊ù ◊î◊û◊ê◊ï◊ó◊®◊ô◊ù ◊©◊ú ◊î◊û◊°◊û◊ö
- ◊™◊ü ◊ì◊í◊© ◊û◊ô◊ï◊ó◊ì ◊ú◊ó◊ú◊ß ◊î◊°◊ï◊§◊ô ◊©◊ú◊¢◊ô◊™◊ô◊ù ◊û◊õ◊ô◊ú ◊§◊®◊ò◊ô ◊ô◊ô◊©◊ï◊ù ◊ó◊©◊ï◊ë◊ô◊ù
- ◊î◊©◊™◊û◊© ◊ë◊¶◊ô◊ò◊ï◊ò◊ô◊ù ◊û◊ô◊ô◊¶◊í◊ô◊ù ◊û◊û◊ß◊ò◊¢◊ô◊ù ◊©◊ï◊†◊ô◊ù ◊ú◊ê◊ï◊®◊ö ◊õ◊ú ◊î◊ò◊ß◊°◊ò
- ◊ï◊ï◊ì◊ê ◊©◊ô◊© ◊ú◊ö ◊™◊ï◊ë◊†◊ï◊™ ◊û◊õ◊ú ◊î◊ß◊®◊ô◊ò◊®◊ô◊ï◊†◊ô◊ù ◊í◊ù ◊û◊î◊ó◊ú◊ß ◊î◊°◊ï◊§◊ô
` : ''}

◊™◊ï◊õ◊ü ◊î◊û◊°◊û◊ö ◊ú◊†◊ô◊™◊ï◊ó:
"""
${truncatedContent}
"""

◊î◊ó◊ñ◊® ◊®◊ß JSON ◊¢◊ù ◊î◊û◊ë◊†◊î ◊î◊ë◊ê (◊ú◊ú◊ê ◊ò◊ß◊°◊ò ◊†◊ï◊°◊£):
{
  "criteria": [12 ◊ß◊®◊ô◊ò◊®◊ô◊ï◊†◊ô◊ù ◊¢◊ù id, name (◊ë◊¢◊ë◊®◊ô◊™), weight, score, justification (◊ë◊¢◊ë◊®◊ô◊™), evidence],
  "summary": { "feasibilityPercent": ◊û◊°◊§◊®, "feasibilityLevel": "low/medium/high", "reasoning": "◊î◊°◊ë◊® ◊ë◊¢◊ë◊®◊ô◊™" },
  "insights": [${adjustedMaxInsights} ◊™◊ï◊ë◊†◊ï◊™ ◊¢◊ù id, criterionId, quote, explanation (◊ë◊¢◊ë◊®◊ô◊™), suggestion (◊ë◊¢◊ë◊®◊ô◊™), suggestion_primary (◊ë◊¢◊ë◊®◊ô◊™), suggestion_secondary (◊ë◊¢◊ë◊®◊ô◊™), rangeStart, rangeEnd]
}

◊ñ◊õ◊ï◊®: ◊õ◊ú ◊î◊ò◊ß◊°◊ò ◊ë◊¢◊ë◊®◊ô◊™, ${adjustedMaxInsights} ◊™◊ï◊ë◊†◊ï◊™ ◊ë◊ì◊ô◊ï◊ß, ◊¶◊ô◊ò◊ï◊ò◊ô◊ù ◊û◊ì◊ï◊ô◊ß◊ô◊ù ◊ï◊ß◊¶◊®◊ô◊ù, ◊õ◊ô◊°◊ï◊ô ◊û◊ú◊ê ◊©◊ú ◊î◊ò◊ß◊°◊ò ◊û◊™◊ó◊ô◊ú◊™◊ï ◊ï◊¢◊ì ◊°◊ï◊§◊ï!`;

      // Step 2: Add a message to the thread
      console.log(`üîÑ ${VERSION} - Step 2: Adding enhanced message to thread`);
      const messageResponse = await fetch(`https://api.openai.com/v1/threads/${threadId}/messages`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          role: 'user',
          content: enhancedPrompt,
        }),
        signal: controller.signal,
      });

      if (!messageResponse.ok) {
        const messageError = await messageResponse.json().catch(() => ({}));
        console.error(`‚ùå ${VERSION} - Message creation failed:`, messageError);
        throw new Error(`Failed to create message: ${messageError.error?.message || 'Unknown error'}`);
      }

      console.log(`‚úÖ ${VERSION} - Enhanced message added to thread`);

      // Step 3: Run the assistant
      console.log(`üîÑ ${VERSION} - Step 3: Running assistant ${assistantId}`);
      const runResponse = await fetch(`https://api.openai.com/v1/threads/${threadId}/runs`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          assistant_id: assistantId,
          response_format: { type: "json_object" }
        }),
        signal: controller.signal,
      });

      if (!runResponse.ok) {
        const runError = await runResponse.json().catch(() => ({}));
        console.error(`‚ùå ${VERSION} - Run creation failed:`, runError);
        throw new Error(`Failed to create run: ${runError.error?.message || 'Unknown error'}`);
      }

      const run = await runResponse.json();
      const runId = run.id;
      console.log(`‚úÖ ${VERSION} - Run created: ${runId}, status: ${run.status}`);

      // Step 4: Enhanced polling for completion with progress tracking
      console.log(`üîÑ ${VERSION} - Step 4: Enhanced polling (max attempts: ${maxPollingAttempts})`);
      let runStatus = run.status;
      let attempts = 0;

      while (['queued', 'in_progress'].includes(runStatus) && attempts < maxPollingAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
        attempts++;
        const progressPercent = Math.round((attempts / maxPollingAttempts) * 100);
        console.log(`üîÑ ${VERSION} - Polling attempt ${attempts}/${maxPollingAttempts} (${progressPercent}%), current status: ${runStatus}`);

        try {
          const statusResponse = await fetch(`https://api.openai.com/v1/threads/${threadId}/runs/${runId}`, {
            headers,
            signal: controller.signal,
          });

          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            runStatus = statusData.status;
            console.log(`üìä ${VERSION} - Status update: ${runStatus}`);
          } else {
            console.error(`‚ùå ${VERSION} - Status check failed: ${statusResponse.status}`);
            throw new Error('Network error during status check');
          }
        } catch (error) {
          console.error(`‚ùå ${VERSION} - Status check exception:`, error);
          throw new Error(`Status check failed: ${error.message}`);
        }
      }

      clearTimeout(timeoutId);

      if (runStatus !== 'completed') {
        console.error(`‚ùå ${VERSION} - Run failed with final status: ${runStatus} after ${attempts} attempts (${attempts * 2}s)`);
        throw new Error(`Analysis timed out or failed with status: ${runStatus} after ${attempts * 2} seconds`);
      }

      console.log(`‚úÖ ${VERSION} - Run completed successfully after ${attempts} polling attempts (${attempts * 2}s)`);

      // Step 5: Get the messages
      console.log(`üîÑ ${VERSION} - Step 5: Retrieving messages`);
      const messagesResponse = await fetch(`https://api.openai.com/v1/threads/${threadId}/messages`, {
        headers,
        signal: controller.signal,
      });

      if (!messagesResponse.ok) {
        const messagesError = await messagesResponse.json().catch(() => ({}));
        console.error(`‚ùå ${VERSION} - Messages retrieval failed:`, messagesError);
        throw new Error(`Failed to get messages: ${messagesError.error?.message || 'Unknown error'}`);
      }

      const messages = await messagesResponse.json();
      const assistantMessage = messages.data.find((msg: any) => msg.role === 'assistant');

      if (!assistantMessage || !assistantMessage.content || !assistantMessage.content[0]) {
        console.error(`‚ùå ${VERSION} - No valid assistant response found`);
        throw new Error('No response from assistant');
      }

      const responseText = assistantMessage.content[0].text.value;
      console.log(`üìÑ ${VERSION} - Response received, length: ${responseText.length}`);

      // Enhanced JSON parsing with multiple extraction methods
      let parsed: any;
      try {
        let jsonText = responseText.trim();
        
        // Method 1: Look for JSON blocks in markdown
        const markdownJsonMatch = jsonText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (markdownJsonMatch) {
          jsonText = markdownJsonMatch[1];
        } else {
          // Method 2: Extract the largest JSON object
          const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            jsonText = jsonMatch[0];
          }
        }
        
        parsed = JSON.parse(jsonText);
        console.log(`‚úÖ ${VERSION} - JSON parsed successfully`);
      } catch (parseError) {
        console.error(`‚ùå ${VERSION} - JSON parse failed:`, parseError);
        console.error(`Raw response (first 500 chars):`, responseText.substring(0, 500));
        // Enhanced fallback structure
        parsed = { insights: [], criteria: [], summary: null };
      }

      // Enhanced processing and validation
      let insights = Array.isArray(parsed.insights)
        ? parsed.insights.slice(0, adjustedMaxInsights).map((i: any, idx: number) => ({
            id: String(i?.id ?? `assistant-${idx}`),
            criterionId: (ALLOWED_CRITERIA as readonly string[]).includes(i?.criterionId) ? i.criterionId : 'timeline',
            quote: String(i?.quote ?? '').trim(), // Trim whitespace from quotes
            explanation: String(i?.explanation ?? ''),
            suggestion: String(i?.suggestion ?? ''),
            suggestion_primary: String(i?.suggestion_primary ?? i?.suggestion ?? ''),
            suggestion_secondary: String(i?.suggestion_secondary ?? ''),
            rangeStart: Number.isFinite(i?.rangeStart) ? i.rangeStart : 0,
            rangeEnd: Number.isFinite(i?.rangeEnd) ? i.rangeEnd : 0,
          }))
        : [];

      const criteria = Array.isArray(parsed.criteria)
        ? parsed.criteria.map((c: any) => ({
            id: (ALLOWED_CRITERIA as readonly string[]).includes(c?.id) ? c.id : 'timeline',
            name: String(c?.name ?? String(c?.id ?? '')),
            weight: Math.max(0, Math.min(100, Number(c?.weight) || 0)),
            score: Math.max(0, Math.min(5, Number(c?.score) || 0)),
            justification: String(c?.justification ?? ''),
            evidence: Array.isArray(c?.evidence) ? c.evidence.map((e: any) => ({
              quote: String(e?.quote ?? '').trim(), // Trim evidence quotes too
              rangeStart: Number.isFinite(e?.rangeStart) ? e.rangeStart : 0,
              rangeEnd: Number.isFinite(e?.rangeEnd) ? e.rangeEnd : 0,
            })) : [],
          }))
        : [];

      // Enhanced synthesis from criteria evidence with better distribution
      if ((!insights || insights.length < adjustedMaxInsights * 0.7) && Array.isArray(criteria)) {
        console.log(`üîÑ ${VERSION} - Synthesizing additional insights from criteria evidence`);
        const synth: any[] = [];
        const existingByCrit = new Set(insights.map((i) => i.criterionId));
        
        for (const c of criteria) {
          if (Array.isArray(c.evidence) && c.evidence.length) {
            const evidenceToUse = existingByCrit.has(c.id) ? 1 : Math.min(c.evidence.length, 3); // More evidence per criterion
            for (let k = 0; k < evidenceToUse; k++) {
              const e = c.evidence[k];
              const defaultSuggestions = getDefaultSuggestions(c.id);
              synth.push({
                id: `${c.id}-ev-${k}`,
                criterionId: c.id,
                quote: String(e.quote || '').trim(),
                explanation: c.justification || `◊™◊ï◊ë◊†◊î ◊¢◊ë◊ï◊® ${c.name}`,
                suggestion: defaultSuggestions.primary,
                suggestion_primary: defaultSuggestions.primary,
                suggestion_secondary: defaultSuggestions.secondary,
                rangeStart: Number.isFinite(e.rangeStart) ? e.rangeStart : 0,
                rangeEnd: Number.isFinite(e.rangeEnd) ? e.rangeEnd : 0,
              });
            }
          }
        }
        
        if (synth.length) {
          insights = [...insights, ...synth].slice(0, adjustedMaxInsights);
          console.log(`‚úÖ ${VERSION} - Added ${synth.length} synthesized insights`);
        }
      }

      let summary = parsed?.summary && typeof parsed.summary === 'object' ? {
        feasibilityPercent: Math.max(0, Math.min(100, Number(parsed.summary.feasibilityPercent) || 0)),
        feasibilityLevel: ['low','medium','high'].includes(parsed.summary.feasibilityLevel) ? parsed.summary.feasibilityLevel : undefined,
        reasoning: String(parsed.summary.reasoning ?? ''),
      } : null;

      if (!summary || !summary.feasibilityLevel) {
        const totalW = criteria.reduce((s: number, c: any) => s + (c.weight || 0), 0) || 1;
        const pct = criteria.reduce((s: number, c: any) => s + ((c.score || 0) / 5) * (c.weight || 0), 0) / totalW * 100;
        const percent = Math.round(pct);
        const level = percent < 50 ? 'low' : percent < 75 ? 'medium' : 'high';
        summary = { feasibilityPercent: percent, feasibilityLevel: level, reasoning: summary?.reasoning || '' } as any;
      }

      console.log(`üéâ ${VERSION} - Analysis completed successfully: ${insights.length} insights, ${criteria.length} criteria`);
      console.log(`üìä ${VERSION} - Final stats: { isLongText: ${isLongText}, originalLength: ${content.length}, insights: ${insights.length}, adjustedMaxInsights: ${adjustedMaxInsights}, duration: ${attempts * 2}s }`);

      return new Response(
        JSON.stringify({ 
          insights, 
          criteria, 
          summary, 
          meta: { source: 'assistants', threadId, runId, version: VERSION, isLongText, originalLength: content.length, duration: `${attempts * 2}s` } 
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );

    } catch (timeoutError) {
      clearTimeout(timeoutId);
      console.error(`‚è∞ ${VERSION} - Request timeout or abort:`, timeoutError);
      throw timeoutError;
    }

  } catch (error) {
    console.error(`üí• ${VERSION} - Fatal error:`, error);
    return new Response(
      JSON.stringify({ error: error.message || 'Analysis failed', version: VERSION }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

// Enhanced helper function with more comprehensive suggestions for each criterion in Hebrew
function getDefaultSuggestions(criterionId: string): { primary: string; secondary: string } {
  const suggestions: Record<string, { primary: string; secondary: string }> = {
    timeline: {
      primary: "◊î◊ï◊°◊ô◊§◊ï ◊ú◊ï◊ó◊ï◊™ ◊ñ◊û◊†◊ô◊ù ◊û◊ó◊ô◊ô◊ë◊ô◊ù ◊¢◊ù ◊™◊ê◊®◊ô◊õ◊ô ◊ô◊¢◊ì ◊ë◊®◊ï◊®◊ô◊ù, ◊ê◊ë◊†◊ô ◊ì◊®◊ö ◊ë◊ô◊†◊ô◊ô◊ù ◊ï◊°◊†◊ß◊¶◊ô◊ï◊™ ◊ë◊ê◊ô-◊¢◊û◊ô◊ì◊î ◊ë◊î◊ù.",
      secondary: "◊¶◊®◊ï ◊û◊¢◊®◊õ◊™ ◊û◊¢◊ß◊ë ◊ï◊ì◊ô◊ï◊ï◊ó ◊©◊ë◊ï◊¢◊ô◊™ ◊¢◊ú ◊î◊™◊ß◊ì◊û◊ï◊™ ◊û◊ï◊ú ◊î◊ú◊ï◊ó ◊ñ◊û◊†◊ô◊ù ◊¢◊ù ◊î◊™◊®◊ê◊ï◊™ ◊û◊ï◊ß◊ì◊û◊ï◊™ ◊¢◊ú ◊¢◊ô◊õ◊ï◊ë◊ô◊ù."
    },
    integrator: {
      primary: "◊î◊í◊ì◊ô◊®◊ï ◊¶◊ï◊ï◊™ ◊û◊™◊õ◊ú◊ú ◊¢◊ù ◊î◊®◊õ◊ë ◊û◊ï◊í◊ì◊®, ◊°◊û◊õ◊ï◊ô◊ï◊™ ◊ë◊®◊ï◊®◊ï◊™, ◊™◊ì◊ô◊®◊ï◊™ ◊ô◊©◊ô◊ë◊ï◊™ ◊ß◊ë◊ï◊¢◊î ◊ï◊†◊î◊ú◊ô ◊ß◊ë◊ú◊™ ◊î◊ó◊ú◊ò◊ï◊™.",
      secondary: "◊ß◊ë◊¢◊ï ◊†◊î◊ú◊ô◊ù ◊ë◊®◊ï◊®◊ô◊ù ◊ú◊™◊ô◊ê◊ï◊ù ◊ë◊ô◊ü-◊û◊©◊®◊ì◊ô ◊ï◊í◊ï◊®◊û◊ô◊ù ◊©◊ï◊†◊ô◊ù ◊¢◊ù ◊ê◊ó◊®◊ô◊ï◊™ ◊û◊ï◊í◊ì◊®◊™ ◊ï◊û◊†◊í◊†◊ï◊†◊ô ◊ô◊ô◊©◊ï◊ë ◊°◊õ◊°◊ï◊õ◊ô◊ù."
    },
    reporting: {
      primary: "◊ß◊ë◊¢◊ï ◊û◊†◊í◊†◊ï◊ü ◊ì◊ô◊ï◊ï◊ó ◊°◊ì◊ô◊®: ◊™◊ì◊ô◊®◊ï◊™ ◊ß◊ë◊ï◊¢◊î, ◊§◊ï◊®◊û◊ò ◊°◊ò◊†◊ì◊®◊ò◊ô, ◊û◊ì◊ì◊ô ◊ë◊ô◊¶◊ï◊¢ ◊ï◊ò◊ô◊§◊ï◊ú ◊ë◊ó◊®◊ô◊í◊ï◊™.",
      secondary: "◊î◊ß◊ô◊û◊ï ◊û◊¢◊®◊õ◊™ ◊û◊ó◊ï◊ï◊†◊ô◊ù ◊ì◊ô◊í◊ô◊ò◊ú◊ô◊™ ◊ú◊û◊¢◊ß◊ë ◊ë◊ñ◊û◊ü ◊ê◊û◊™ ◊ê◊ó◊® ◊î◊™◊ß◊ì◊û◊ï◊™ ◊ï◊î◊ô◊©◊í◊ô◊ù ◊¢◊ù ◊ì◊©◊ë◊ï◊®◊ì ◊û◊†◊î◊ú◊ô◊ù."
    },
    evaluation: {
      primary: "◊î◊ï◊°◊ô◊§◊ï ◊û◊ì◊ì◊ô◊ù ◊õ◊û◊ï◊™◊ô◊ô◊ù ◊ï◊ê◊ô◊õ◊ï◊™◊ô◊ô◊ù ◊ë◊®◊ï◊®◊ô◊ù, ◊©◊ô◊ò◊™ ◊î◊¢◊®◊õ◊î ◊û◊ó◊ñ◊ï◊®◊ô◊™ ◊ï◊™◊ô◊¢◊ï◊ì ◊©◊ô◊ò◊™◊ô ◊©◊ú ◊™◊ï◊¶◊ê◊ï◊™.",
      secondary: "◊ß◊ë◊¢◊ï ◊í◊ï◊®◊ù ◊ó◊ô◊¶◊ï◊†◊ô ◊¢◊¶◊û◊ê◊ô ◊ú◊î◊¢◊®◊õ◊™ ◊î◊©◊§◊¢◊î ◊ï◊ô◊¢◊ô◊ú◊ï◊™ ◊î◊™◊ï◊õ◊†◊ô◊™ ◊¢◊ù ◊ë◊ì◊ô◊ß◊ï◊™ ◊ê◊ô◊õ◊ï◊™ ◊™◊ß◊ï◊§◊™◊ô◊ï◊™."
    },
    external_audit: {
      primary: "◊ß◊ë◊¢◊ï ◊ë◊ô◊ß◊ï◊®◊™ ◊ó◊ô◊¶◊ï◊†◊ô◊™ ◊¢◊¶◊û◊ê◊ô◊™ ◊¢◊ù ◊û◊ï◊¢◊ì◊ô◊ù ◊ß◊ë◊ï◊¢◊ô◊ù, ◊û◊™◊ï◊ì◊ï◊ú◊ï◊í◊ô◊î ◊ë◊®◊ï◊®◊î ◊ï◊ó◊ï◊ë◊™ ◊§◊®◊°◊ï◊ù ◊î◊û◊û◊¶◊ê◊ô◊ù.",
      secondary: "◊î◊í◊ì◊ô◊®◊ï ◊†◊î◊ú◊ô ◊ò◊ô◊§◊ï◊ú ◊ë◊û◊û◊¶◊ê◊ô ◊î◊ë◊ô◊ß◊ï◊®◊™, ◊ú◊ï◊ó◊ï◊™ ◊ñ◊û◊†◊ô◊ù ◊ú◊ô◊ô◊©◊ï◊ù ◊î◊û◊ú◊¶◊ï◊™ ◊ï◊û◊¢◊ß◊ë ◊ê◊ó◊® ◊î◊©◊ú◊û◊™◊ù."
    },
    resources: {
      primary: "◊§◊®◊ò◊ï ◊ê◊™ ◊î◊™◊ß◊¶◊ô◊ë ◊î◊†◊ì◊®◊© ◊ú◊§◊ô ◊©◊†◊ô◊ù ◊ï◊§◊¢◊ô◊ú◊ï◊ô◊ï◊™, ◊û◊ß◊ï◊®◊ï◊™ ◊î◊û◊ô◊û◊ï◊ü ◊ï◊õ◊ï◊ó ◊î◊ê◊ì◊ù ◊î◊ì◊®◊ï◊© ◊ú◊ë◊ô◊¶◊ï◊¢.",
      secondary: "◊ß◊ë◊¢◊ï ◊û◊†◊í◊†◊ï◊ü ◊ë◊ß◊®◊™ ◊™◊ß◊¶◊ô◊ë ◊©◊ï◊ò◊£ ◊¢◊ù ◊®◊ñ◊®◊ë◊ï◊™ ◊ú◊ò◊ô◊§◊ï◊ú ◊ë◊ó◊®◊ô◊í◊ï◊™ ◊¢◊ú◊ï◊™ ◊ï◊†◊î◊ú◊ô ◊ê◊ô◊©◊ï◊® ◊©◊ô◊†◊ï◊ô◊ô◊ù."
    },
    multi_levels: {
      primary: "◊î◊ë◊î◊ô◊®◊ï ◊ê◊™ ◊ó◊ú◊ï◊ß◊™ ◊î◊ê◊ó◊®◊ô◊ï◊™ ◊ï◊î◊°◊û◊õ◊ï◊ô◊ï◊™ ◊ë◊ô◊ü ◊î◊ì◊®◊í◊ô◊ù ◊î◊©◊ï◊†◊ô◊ù ◊¢◊ù ◊î◊í◊ì◊®◊™ ◊û◊û◊©◊ß◊ô ◊¢◊ë◊ï◊ì◊î ◊ë◊®◊ï◊®◊ô◊ù.",
      secondary: "◊¶◊®◊ï ◊û◊¢◊®◊õ◊™ ◊™◊ß◊©◊ï◊®◊™ ◊ï◊ì◊ô◊ï◊ï◊ó ◊î◊ô◊®◊®◊õ◊ô◊™ ◊ë◊ô◊ü ◊î◊®◊û◊ï◊™ ◊î◊©◊ï◊†◊ï◊™ ◊¢◊ù ◊î◊í◊ì◊®◊™ ◊†◊î◊ú◊ô ◊î◊°◊ú◊û◊î ◊ï◊™◊ô◊ê◊ï◊ù."
    },
    structure: {
      primary: "◊ó◊ú◊ß◊ï ◊ê◊™ ◊î◊™◊ï◊õ◊†◊ô◊™ ◊ú◊û◊©◊ô◊û◊ï◊™ ◊°◊§◊¶◊ô◊§◊ô◊ï◊™ ◊¢◊ù ◊ë◊¢◊ú◊ô ◊™◊§◊ß◊ô◊ì◊ô◊ù ◊û◊ï◊í◊ì◊®◊ô◊ù, ◊ê◊ë◊†◊ô ◊ì◊®◊ö ◊ë◊®◊ï◊®◊ï◊™ ◊ï◊û◊ì◊ì◊ô ◊î◊¶◊ú◊ó◊î.",
      secondary: "◊î◊í◊ì◊ô◊®◊ï ◊û◊ë◊†◊î ◊ê◊®◊í◊ï◊†◊ô ◊î◊ô◊®◊®◊õ◊ô ◊¢◊ù ◊™◊ô◊ê◊ï◊®◊ô ◊™◊§◊ß◊ô◊ì◊ô◊ù ◊û◊§◊ï◊®◊ò◊ô◊ù, ◊°◊û◊õ◊ï◊ô◊ï◊™ ◊ë◊®◊ï◊®◊ï◊™ ◊ï◊†◊î◊ú◊ô ◊¢◊ë◊ï◊ì◊î ◊ú◊õ◊ú ◊®◊û◊î."
    },
    field_implementation: {
      primary: "◊™◊ê◊®◊ï ◊ë◊§◊ô◊®◊ï◊ò ◊ê◊™ ◊î◊ô◊ô◊©◊ï◊ù ◊ë◊©◊ò◊ó: ◊û◊ô ◊û◊ë◊¶◊¢, ◊ê◊ô◊ö, ◊ë◊ê◊ô◊ú◊ï ◊°◊û◊õ◊ï◊ô◊ï◊™, ◊§◊ô◊ß◊ï◊ó ◊ï◊ë◊ß◊®◊î ◊ô◊ï◊û◊ô◊ï◊û◊ô◊™.",
      secondary: "◊î◊ß◊ô◊û◊ï ◊û◊¢◊®◊õ◊™ ◊î◊õ◊©◊®◊î ◊ï◊î◊ì◊®◊õ◊î ◊ú◊û◊ë◊¶◊¢◊ô◊ù ◊ë◊©◊ò◊ó ◊¢◊ù ◊õ◊ú◊ô◊ù ◊û◊¢◊©◊ô◊ô◊ù, ◊û◊ì◊®◊ô◊õ◊ô◊ù ◊ï◊™◊û◊ô◊õ◊î ◊©◊ï◊ò◊§◊™."
    },
    arbitrator: {
      primary: "◊û◊†◊ï ◊í◊ï◊®◊ù ◊û◊õ◊®◊ô◊¢ ◊ë◊õ◊ô◊® ◊¢◊ù ◊ñ◊û◊ü ◊™◊í◊ï◊ë◊î ◊ë◊®◊ï◊® ◊ú◊ß◊ë◊ú◊™ ◊î◊ó◊ú◊ò◊ï◊™ ◊ë◊ó◊°◊ô◊û◊ï◊™ ◊ï◊°◊õ◊°◊ï◊õ◊ô◊ù ◊ë◊ô◊ü-◊ê◊®◊í◊ï◊†◊ô◊ô◊ù.",
      secondary: "◊î◊í◊ì◊ô◊®◊ï ◊†◊î◊ú◊ô ◊î◊°◊ú◊û◊î ◊û◊ì◊ï◊®◊í◊ô◊ù ◊ï◊ß◊ë◊ú◊™ ◊î◊ó◊ú◊ò◊ï◊™ ◊ë◊û◊ß◊®◊ô◊ù ◊û◊ï◊®◊õ◊ë◊ô◊ù ◊¢◊ù ◊°◊û◊õ◊ï◊ô◊ï◊™ ◊ó◊ì-◊û◊©◊û◊¢◊ô◊ï◊™."
    },
    cross_sector: {
      primary: "◊©◊ú◊ë◊ï ◊û◊†◊í◊†◊ï◊ü ◊©◊ô◊™◊ï◊£ ◊§◊¢◊ï◊ú◊î ◊¢◊ù ◊¶◊ô◊ë◊ï◊® ◊ï◊ë◊¢◊ú◊ô ◊¢◊†◊ô◊ô◊ü ◊®◊ú◊ï◊ï◊†◊ò◊ô◊ô◊ù, ◊™◊ô◊ê◊ï◊ù ◊ë◊ô◊ü-◊û◊©◊®◊ì◊ô ◊ï◊û◊û◊©◊ß ◊¢◊ù ◊û◊í◊ñ◊® ◊§◊®◊ò◊ô.",
      secondary: "◊¶◊®◊ï ◊ï◊¢◊ì◊™ ◊î◊ô◊í◊ï◊ô ◊®◊ë-◊í◊ñ◊®◊ô◊™ ◊¢◊ù ◊†◊¶◊ô◊í◊ï◊™ ◊®◊ó◊ë◊î ◊û◊õ◊ú ◊î◊í◊ï◊®◊û◊ô◊ù ◊î◊®◊ú◊ï◊ï◊†◊ò◊ô◊ô◊ù ◊ï◊û◊†◊í◊†◊ï◊ü ◊ß◊ë◊ú◊™ ◊î◊ó◊ú◊ò◊ï◊™ ◊ß◊ï◊†◊°◊†◊ñ◊ï◊ê◊ú◊ô."
    },
    outcomes: {
      primary: "◊î◊í◊ì◊ô◊®◊ï ◊û◊ì◊ì◊ô ◊™◊ï◊¶◊ê◊î ◊ë◊®◊ï◊®◊ô◊ù ◊ï◊ô◊¢◊ì◊ô ◊î◊¶◊ú◊ó◊î ◊û◊°◊§◊®◊ô◊ô◊ù ◊î◊†◊ô◊™◊†◊ô◊ù ◊ú◊û◊ì◊ô◊ì◊î ◊¢◊ù ◊ú◊ï◊ó◊ï◊™ ◊ñ◊û◊†◊ô◊ù ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù.",
      secondary: "◊ß◊ë◊¢◊ï ◊û◊¢◊®◊õ◊™ ◊û◊¢◊ß◊ë ◊ê◊ó◊® ◊î◊©◊§◊¢◊î ◊ê◊®◊ï◊õ◊™ ◊ò◊ï◊ï◊ó ◊¢◊ù ◊î◊¢◊®◊õ◊î ◊™◊ß◊ï◊§◊™◊ô◊™ ◊ï◊î◊©◊ï◊ï◊ê◊î ◊ú◊û◊ì◊ô◊†◊ï◊™ ◊ì◊ï◊û◊ï◊™."
    }
  };

  return suggestions[criterionId] || {
    primary: "◊©◊§◊®◊ï ◊ê◊™ ◊î◊°◊¢◊ô◊£ ◊ë◊î◊™◊ê◊ù ◊ú◊ì◊®◊ô◊©◊ï◊™ ◊î◊®◊ï◊ë◊®◊ô◊ß◊î ◊¢◊ù ◊§◊ô◊®◊ï◊ò ◊†◊ï◊°◊£ ◊ï◊î◊í◊ì◊®◊ï◊™ ◊ë◊®◊ï◊®◊ï◊™ ◊ô◊ï◊™◊®.",
    secondary: "◊î◊ï◊°◊ô◊§◊ï ◊û◊†◊í◊†◊ï◊†◊ô ◊ë◊ß◊®◊î ◊ï◊û◊¢◊ß◊ë ◊û◊™◊ê◊ô◊û◊ô◊ù ◊¢◊ù ◊î◊í◊ì◊®◊™ ◊ê◊ó◊®◊ô◊ï◊™ ◊ï◊ú◊ï◊ó◊ï◊™ ◊ñ◊û◊†◊ô◊ù ◊ú◊ë◊ô◊¶◊ï◊¢."
  };
}
